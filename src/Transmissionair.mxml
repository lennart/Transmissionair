<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009" 
					   xmlns:s="library://ns.adobe.com/flex/spark" 
					   xmlns:mx="library://ns.adobe.com/flex/halo" creationComplete="windowedapplication1_creationCompleteHandler(event)" implements="flash.events.IEventDispatcher" xmlns:local="*">
	<fx:Binding source="{_torrentList}" destination="torrentListView.dataProvider"	/>
	<fx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSON;
			
			import flash.events.Event;
			import flash.events.HTTPStatusEvent;
			import flash.events.IEventDispatcher;
			import flash.net.URLLoader;
			import flash.net.URLRequest;
			import flash.net.URLRequestMethod;
			import flash.utils.ByteArray;
			import flash.utils.Timer;
			
			import mx.collections.ArrayCollection;
			import mx.managers.DragManager;
			import mx.utils.Base64Encoder;
			private const SESSION_HEADER_KEY:String = "X-Transmission-Session-Id";
			import mx.events.FlexEvent;
			private const HOST:String = "http://10.23.41.3:9091";
			private const RPC_ROOT:String = "/transmission/rpc";
			private var sessionID:String;
			[Bindable]
			private var _torrentList:ArrayCollection = new ArrayCollection();
			private var pollTorrents:Timer = new Timer(500);
			private var addTorrentLoader:URLLoader = new URLLoader();
			private var torrentFileStream:FileStream = new FileStream();
			private var urlLoader:URLLoader = new URLLoader();
			protected function windowedapplication1_creationCompleteHandler(event:FlexEvent):void
			{
				var req:URLRequest = new URLRequest();	
				req.url = HOST+RPC_ROOT;
				req.method = URLRequestMethod.GET;
				urlLoader.addEventListener(HTTPStatusEvent.HTTP_RESPONSE_STATUS,sessionIdReceived);
				urlLoader.load(req);				
			}
			
			protected function fetchTorrentList() :void {
				var req:URLRequest = new URLRequest();	
				var reqData:Object = new Object();
				var reqDataBA:ByteArray = new ByteArray();
				reqData.arguments = new Object();
				reqData.arguments.fields = ["id","name","totalSize", "percentDone"];
				reqData.method = "torrent-get";
				req.requestHeaders.push(new URLRequestHeader(SESSION_HEADER_KEY,sessionID));
				req.requestHeaders.push(new URLRequestHeader("Accept","application/json"));
				req.url = HOST+RPC_ROOT;
				reqDataBA.writeUTFBytes(JSON.encode(reqData));
				reqDataBA.position = 0;
				req.data =  reqDataBA;
				req.method = URLRequestMethod.POST;
				urlLoader.addEventListener(Event.COMPLETE,torrentListReceived);
				urlLoader.load(req);
			}
			private function torrentListReceived(e:Event):void {
				var response:Object = JSON.decode(e.currentTarget.data);
				if(response.result == "success") {
					torrentList = response.arguments.torrents;
					urlLoader.removeEventListener(Event.COMPLETE,torrentListReceived);
				}
				else {
					throw new Error("Failed to fetch Torrents");	
				}					
			}
			
			public function set torrentList(torrents:Array) : void {
				if (_torrentList.length == 0) {
					for (var index:int = 0; index < torrents.length; index++) {						
						_torrentList.addItem(torrents[index]);
					}
				}
				else {
					
					var length:int = (_torrentList.length > torrents.length) ? _torrentList.length : torrents.length;
					var index:int = 0;
					while(index < length) {
						
						if (index > torrents.length-1) {							
							_torrentList.removeItemAt(index);	
							length -= 1;
						}
						else if(index > _torrentList.length-1) {
							_torrentList.addItem(torrents[index]);
							index += 2;
							length +=1;
						}
						else if(_torrentList[index].id != torrents[index].id) {
							if(index < (torrents.length-1)) {
								if(torrents[index+1].id == _torrentList[index].id) {
									
									_torrentList.addItemAt(torrents[index],index-1);
									index += 2;
									length += 1;
								} 
								else if (torrents[index].id == _torrentList[index+1].id) {
									//torrents.splice(index,1);
									//torrents.splice(index-1,0, _torrentList[index]);
									_torrentList.removeItemAt(index);
									length -= 1;
								}
							}
						}
						else {
							updateJSONRepresentation(index, torrents[index]);
							//_torrentList[index] = torrents[index];
							index++;
						}
					}	
				}
			}
			
			private function updateJSONRepresentation(index, item) : void {				
				for (var key in item) {
					_torrentList[index][key] = item[key];
				}
			}
			
			private function addTorrentFile(e:Event):void {
				var req:URLRequest = new URLRequest();	
				var reqData:Object = new Object();
				var reqDataBA:ByteArray = new ByteArray();
				reqData.arguments = new Object();
				var enc:Base64Encoder = new Base64Encoder();
				
				var torrentFileData:ByteArray = new ByteArray();
				torrentFileStream.readBytes(torrentFileData);
				enc.encodeBytes(torrentFileData);
				
				
				reqData.arguments.metainfo = enc.toString();
				reqData.method = "torrent-add";
				req.requestHeaders.push(new URLRequestHeader(SESSION_HEADER_KEY,sessionID));
				req.requestHeaders.push(new URLRequestHeader("Accept","application/json"));
				req.url = HOST+RPC_ROOT;
				reqDataBA.writeUTFBytes(JSON.encode(reqData));
				reqDataBA.position = 0;
				req.data =  reqDataBA;
				req.method = URLRequestMethod.POST;
				addTorrentLoader.addEventListener(Event.COMPLETE,torrentFileAdded);
				addTorrentLoader.load(req);
			}
			
			private function torrentFileAdded(e:Event) :void {
				var response:Object = JSON.decode(e.currentTarget.data);
				if(response.result == "success") {
					trace("File Added");
				}
				else {
					trace("File adding failed");
				}
			} 
			
			private function torrentStart(e:TorrentRPCEvent) : void {
				
			}
			
			private function torrentPause(e:TorrentRPCEvent) : void {
				
			}
			
			private function loadTorrentFile(file:File) {
				torrentFileStream.addEventListener(Event.COMPLETE,addTorrentFile);
				torrentFileStream.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);
				torrentFileStream.openAsync(file,FileMode.READ);								
			}
			
			private function ioErrorHandler(e:IOErrorEvent):void {
				trace(e);
			}
			
			private function sessionIdReceived(e:HTTPStatusEvent):void {
				urlLoader.removeEventListener(HTTPStatusEvent.HTTP_RESPONSE_STATUS,sessionIdReceived);
				for each (var header:Object in e.responseHeaders) {
					if(header["name"] == SESSION_HEADER_KEY) {
						sessionID = header["value"];
						pollTorrents.addEventListener(TimerEvent.TIMER,fetchTorrentList);
						pollTorrents.start();
					}
				}
			}
			
			
		]]>
	</fx:Script>
	<local:TransmissionAirContext contextView="{this}"/>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<s:List id="torrentListView" width="100%" height="100%" itemRenderer="Torrent">
		
		<s:layout>
			<s:VerticalLayout />
			
		</s:layout>
		
		
	</s:List>
	<s:nativeDragEnter>
		// Event handler for when something is dragged over to the WindowedApplication
		
		// Only allow files to be dragged in
		if (event.clipboard.hasFormat(ClipboardFormats.FILE_LIST_FORMAT))
		{
		var files:Array = event.clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array;
		DragManager.acceptDragDrop(event.currentTarget as WindowedApplication);	
		}
	</s:nativeDragEnter>
	
	<s:nativeDragExit>
		// Event handler for when the drag leaves the WindowedApplication
		setStyle("backgroundColor", 0xffffff);
	</s:nativeDragExit>
	
	<s:nativeDragDrop>
		// Event handler for when a dragged item is dropped on the WindowedApplication
		for each ( var file in event.clipboard.getData(ClipboardFormats.FILE_LIST_FORMAT) as Array) {
		loadTorrentFile(file);
		}
	</s:nativeDragDrop>
</s:WindowedApplication>
